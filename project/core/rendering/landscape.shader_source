// in this context include refers to another shader file 
includes = [ "core/rendering/common.shader_source" ] 

render_states = {
	wireframe = {
		inherits = "opacity"
		states = {
			fill_mode = "fill_wireframe"	
			z_write_enable = "true"
			z_func = "less"
			defined_D3D11 = {
				depth_bias = "-1"
				depth_bias_clamp = "-0.00015"
				slope_scale_depth_bias = "-2.0"
			}			
		}		
	}	
	
	landscape = {
		inherits = "gbuffer_material"
		states = {
			fill_mode = "fill_solid"
			cull_mode = "cull_ccw"
		}
	}
	
	filter = {
		inherits = "default"
		states = {
			z_write_enable = "false"
			z_enable = "false"
		}
	}

	brush = {
		inherits = "filter"
		states = {
			ndefined_SAMPLE_BASED = {
				ndefined_SAMPLE_HEIGHT = {
					ndefined_FLATTEN = {
						blend_enable = "true"
						defined_SUB = {
							blend_op = "blend_op_rev_sub"
						}
						ndefined_SUB = {				
							blend_op = "blend_op_add"
						}
						dest_blend = "blend_one"
						src_blend = "blend_one"				
					}
				}
			}
		}
	}	

	marker = {
		inherits = "opacity"
		states = {
			cull_mode = "cull_cw"
			z_func = "greater_equal"
			//blend_op = "blend_op_add"
			//dest_blend = "blend_one"
			//src_blend = "blend_one"
		}
	}
	
	depth_only = {
		inherits = "default"
		states = {
			write_mask0 = "0x0"
			write_mask1 = "0x0"
			write_mask2 = "0x0"
			write_mask3 = "0x0"
		}
	}	
	
	shadow_caster = {
		inherits = "depth_only"
		states = {
			defined_D3D11 = {
				depth_bias = "0xff"			
				slope_scale_depth_bias = "1.0"		
			}
			defined_GCM = {				
				offset_units = "5.0"
				offset_factor = "1.0"
			}
			defined_GL2 = {
				offset_units = "1.0"
				offset_factor = "2.0"
				depth_bias_enable = "true"
			}
		}
	}		
}

sampler_states = {
	landscape_anisotropic = {
		inherits = "wrap_anisotropic"
		states = {
			ndefined_GL2 = {
				max_anisotropy = "0x4"
			}
			defined_GL2 = {
				max_anisotropy = "16.0"
			}			
			defined_X360 = {
				trilinear_threshold = "trilinear_one_fourth"
			}
		}	
	}
	landscape_anisotropic_srgb = {
		inherits = "wrap_anisotropic_srgb"
		states = { 
			ndefined_GL2 = {
				max_anisotropy = "0x4"
			}
			defined_GL2 = {
				max_anisotropy = "16.0"
			}
			defined_X360 = {
				trilinear_threshold = "trilinear_one_fourth"
				max_anisotropy = "0x2"
			}			
		}	
	}		
}

hlsl_shaders = {
	landscape_shared = {
		code="""
			float2 morph(float2 uv, float2 wp, float t, float gsize, float psize) {
				float3 grid_size = { gsize, gsize*0.5, 2.f/gsize };
				float2 frac_part = (frac(uv*grid_size.yy) * grid_size.zz) * psize.xx;
				return wp - frac_part * t;				
			}
			
				#if defined(D3D11)
					float3 normal_from_hmap(Texture2D<float> height_map, sampler s, float2 uv, float2 texel_size, float texel_aspect) {
						float4 h = {
							height_map.Sample(s, uv + texel_size * float2(-1, 0)).r,
							height_map.Sample(s, uv + texel_size * float2(1, 0)).r,
							height_map.Sample(s, uv + texel_size * float2(0, -1)).r,
							height_map.Sample(s, uv + texel_size * float2(0, 1)).r
						};
				#elif defined(GL2) || defined(GCM)
					float3 normal_from_hmap(sampler2D height_map, float2 uv, float2 texel_size, float texel_aspect) {						
						float4 h = {
							tex2D(height_map, uv + texel_size * float2(-1, 0)).r,
							tex2D(height_map, uv + texel_size * float2(1, 0)).r,
							tex2D(height_map, uv + texel_size * float2(0, 1)).r,
							tex2D(height_map, uv + texel_size * float2(0, -1)).r
						};
				#elif defined(X360)
					float3 normal_from_hmap(sampler2D height_map, float2 uv, float texel_aspect) {
						float4 h;
						asm {
							  tfetch2D h.x___, uv, height_map, OffsetX = -1.0, OffsetY = 0.0
							  tfetch2D h._x__, uv, height_map, OffsetX = 1.0, OffsetY = 0.0
							  tfetch2D h.__x_, uv, height_map, OffsetX = 0.0, OffsetY = -1.0
							  tfetch2D h.___x, uv, height_map, OffsetX = 0.0, OffsetY = 1.0
						};						
						
				#endif				
					h *= texel_aspect;
					
					float3 n = {
						h[0] - h[1], 
						h[3] - h[2],
						2
					};				
					
					return normalize(n);
				}
		"""
	}
	
	
	landscape_depth = {
		includes = [ "common", "landscape_shared" ]
		
		samplers = {		
			defined_D3D11 = {
				clamp_linear = { sampler_states = "clamp_linear" }
			}
			ndefined_D3D11 = {
				hmap = { sampler_states ="clamp_linear" }
			}
		}
		
		code="""
			struct VS_INPUT {
				float2 position : POSITION;
				#if defined(GL2)
					float4 pos_scale : TEXCOORD0;
					float4 tile_info : TEXCOORD1;
				#endif
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
			};
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float4x4 world;
				float3 landscape_size;
				float3 lod_camera_pos;
				#ifdef X360
					float vertices_per_patch;
				#endif				
			CBUFFER_END
			
			#if defined(D3D11)
				sampler clamp_linear;			
				Texture2D<float> hmap;	
				Buffer<float4> idata;
			#elif defined(GL2)
				sampler2D hmap;
			#endif
			 
			#if defined(X360)
				sampler2D hmap;			
				sampler vdata : register(vf0);
				sampler idata : register(vf1); 

				PS_INPUT vs_main(int index : INDEX) {					
					VS_INPUT input;
					
					int outer_index = (index + 0.5) / (int)vertices_per_patch;
					
					float4 pos_scale, tile_info;		
					asm { 
						vfetch_full pos_scale, outer_index, idata, DataFormat=FMT_32_32_32_32_FLOAT, Stride=8, PrefetchCount=8
						vfetch_mini tile_info, DataFormat=FMT_32_32_32_32_FLOAT, Offset=4
					}; 
					
					
					float4 position;
					int inner_index = index - outer_index * (int)vertices_per_patch;	
					asm { 
						vfetch_full position, inner_index, vdata, DataFormat=FMT_32_32_FLOAT, Stride=2, PrefetchCount=2						
					};
					
					input.position = position;					
			#else
				PS_INPUT vs_main(VS_INPUT input 
					#ifdef D3D11
						, uint instance_id : SV_InstanceId
					#endif
					)
				{
			#endif			
				PS_INPUT o;
				
				#if defined(GL2)
					float4 pos_scale = input.pos_scale;
					float4 tile_info = input.tile_info;
				#elif defined(D3D11)
					float4 pos_scale = idata.Load(instance_id * 2 + 0);
					float4 tile_info = idata.Load(instance_id * 2 + 1);
				#endif				
				
				float2 half_size = landscape_size.xy * 0.5;
				float2 mip = input.position.xy;
				float2 pos = (mip.xy - 0.5) * pos_scale.zw + pos_scale.xy;
				
				float3 p = mul(float4(pos, 0, 1), world);
				float t = 1-saturate((distance(p, lod_camera_pos) - (tile_info.x - pos_scale.z*0.5)) / tile_info.y);
				pos = morph(input.position.xy, pos, t, 32, pos_scale.z);

				float2 huv = ((pos.xy / half_size) * 0.5 + 0.5);
				#if defined(D3D11) || defined(X360)
					huv.y = 1-huv.y;
				#endif
				
				#if defined(D3D11)
					float h = hmap.SampleLevel(clamp_linear, huv, 0).r * landscape_size.z;
				#else
					float h = tex2Dlod(hmap, float4(huv,0,0)).r * landscape_size.z;
				#endif
				
				o.position = mul(float4(pos.xy, h, 1), world_view_proj);
				
				return o;
			}
			
			#ifndef X360
				float4 ps_main(PS_INPUT input) : SV_TARGET0 {
					return float4(1,1,1,1);
				}
			#endif
		"""
	}
	
	landscape = {
		includes = [ "common", "gbuffer_access", "landscape_shared" ]
		
		samplers = {		
			defined_D3D11 = {
				clamp_linear = { sampler_states = "clamp_linear" }
			}
			ndefined_D3D11 = {
				hmap = { sampler_states = "clamp_linear" }
			}
			blend_mask = { sampler_states = "clamp_linear" }
			defined_DIFFUSE_MAP = {
				diffuse_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_MATERIAL_MAP = {
				material_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_NORMAL_MAP = {
				normal_map = { sampler_states = "wrap_anisotropic" }
			}
			
			defined_RED_DIFFUSE_MAP = {
				first_blend_diffuse_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_RED_NORMAL_MAP = {
				first_blend_normal_map = { sampler_states = "landscape_anisotropic" }
			}
			defined_RED_MATERIAL_MAP = {
				first_blend_material_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			
			defined_GREEN_DIFFUSE_MAP = {
				second_blend_diffuse_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_GREEN_NORMAL_MAP = {
				second_blend_normal_map = { sampler_states = "landscape_anisotropic" }
			}
			defined_GREEN_MATERIAL_MAP = {
				second_blend_material_map = { sampler_states = "landscape_anisotropic_srgb" }
			}		
			
			defined_BLUE_DIFFUSE_MAP = {
				third_blend_diffuse_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_BLUE_NORMAL_MAP = {
				third_blend_normal_map = { sampler_states = "landscape_anisotropic" }
			}
			defined_BLUE_MATERIAL_MAP = {
				third_blend_material_map = { sampler_states = "landscape_anisotropic_srgb" }
			}			
			
			defined_ALPHA_DIFFUSE_MAP = {
				fourth_blend_diffuse_map = { sampler_states = "landscape_anisotropic_srgb" }
			}
			defined_ALPHA_NORMAL_MAP = {
				fourth_blend_normal_map = { sampler_states = "landscape_anisotropic" }
			}
			defined_ALPHA_MATERIAL_MAP = {
				fourth_blend_material_map = { sampler_states = "landscape_anisotropic_srgb" }
			}			
		}
		
		code="""
			struct VS_INPUT {
				float2 position : POSITION;
				#if defined(GL2)
					float4 pos_scale : TEXCOORD0;
					float4 tile_info : TEXCOORD1;
				#endif
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
				float2 uv : TEXCOORD0;
				float2 depth : TEXCOORD1;
				float4 color : COLOR;
			};
			
			#ifdef DIFFUSE_MAP
				sampler2D diffuse_map; // exports={ name="Diffuse Map" type="resource" sort_tag="0_DIFFUSE_MAP"}
			#endif			

			#ifdef MATERIAL_MAP
				sampler2D material_map; // exports={ name="Material Map" type="resource" sort_tag="0_MATERIAL_MAP" }
			#endif
			#ifdef NORMAL_MAP
				sampler2D normal_map; // exports={ name="Normal Map" type="resource" sort_tag="0_MATERIAL_MAP" }
			#endif
			
			#ifdef RED_DIFFUSE_MAP
				sampler2D first_blend_diffuse_map; // exports={ name="Red Blend - Diffuse Map" type="resource" sort_tag="1_DIFFUSE_MAP"}
			#endif			
			#ifdef RED_NORMAL_MAP 
				sampler2D first_blend_normal_map; // exports={ name="Red Blend - Normal Map" type="resource" sort_tag="1_NORMAL_MAP"}
			#endif
			#ifdef RED_MATERIAL_MAP
				sampler2D first_blend_material_map; // exports={ name="Red Blend - Material Map" type="resource" sort_tag="1_MATERIAL_MAP"}
			#endif
			
			#ifdef GREEN_DIFFUSE_MAP
				sampler2D second_blend_diffuse_map; // exports={ name="Green Blend - Diffuse Map" type="resource" sort_tag="2_DIFFUSE_MAP"}
			#endif			
			#ifdef GREEN_NORMAL_MAP 
				sampler2D second_blend_normal_map; // exports={ name="Green Blend - Normal Map" type="resource" sort_tag="2_NORMAL_MAP"}
			#endif
			#ifdef GREEN_MATERIAL_MAP
				sampler2D second_blend_material_map; // exports={ name="Green Blend - Material Map" type="resource" sort_tag="2_MATERIAL_MAP"}
			#endif

			#ifdef BLUE_DIFFUSE_MAP
				sampler2D third_blend_diffuse_map; // exports={ name="Blue Blend - Diffuse Map" type="resource" sort_tag="3_DIFFUSE_MAP"}
			#endif			
			#ifdef BLUE_NORMAL_MAP 
				sampler2D third_blend_normal_map; // exports={ name="Blue Blend - Normal Map" type="resource" sort_tag="3_NORMAL_MAP"}
			#endif
			#ifdef BLUE_MATERIAL_MAP
				sampler2D third_blend_material_map; // exports={ name="Blue Blend - Material Map" type="resource" sort_tag="3_MATERIAL_MAP"}
			#endif			

			#ifdef ALPHA_DIFFUSE_MAP
				sampler2D fourth_blend_diffuse_map; // exports={ name="Alpha Blend - Diffuse Map" type="resource" sort_tag="4_DIFFUSE_MAP"}
			#endif			
			#ifdef ALPHA_NORMAL_MAP 
				sampler2D fourth_blend_normal_map; // exports={ name="Alpha Blend - Normal Map" type="resource" sort_tag="4_NORMAL_MAP"}
			#endif
			#ifdef ALPHA_MATERIAL_MAP
				sampler2D fourth_blend_material_map; // exports={ name="Alpha Blend - Material Map" type="resource" sort_tag="4_MATERIAL_MAP"}
			#endif			
			
			#if defined(DIFFUSE_MAP) || defined(MATERIAL_MAP) || defined(NORMAL_MAP)
				#define BASE_MAP
			#endif
			
			#if defined(RED_DIFFUSE_MAP) || defined(RED_NORMAL_MAP) || defined(RED_MATERIAL_MAP)
				#define RED_BLEND
			#endif
			#if defined(GREEN_DIFFUSE_MAP) || defined(GREEN_NORMAL_MAP) || defined(GREEN_MATERIAL_MAP)
				#define GREEN_BLEND
			#endif
			#if defined(BLUE_DIFFUSE_MAP) || defined(BLUE_NORMAL_MAP) || defined(BLUE_MATERIAL_MAP)
				#define BLUE_BLEND
			#endif
			#if defined(ALPHA_DIFFUSE_MAP) || defined(ALPHA_NORMAL_MAP) || defined(ALPHA_MATERIAL_MAP)
				#define ALPHA_BLEND
			#endif
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float4x4 world;
				float3 landscape_size;
				float3 lod_camera_pos;
				#ifdef BASE_MAP
					float2 base_map_scale; // exports={ name="Base Map - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] }
				#endif
				#ifndef MATERIAL_MAP
					float glossiness; 	// exports={ name="Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="0_MATERIAL_MAP_0" }
					float specular; 	// exports={ name="Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="0_MATERIAL_MAP_1" }
				#endif
				
				#ifdef RED_BLEND
					float2 red_maps_scale; // exports={ name="Red Blend - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] sort_tag="1_BLEND_SMOOTHING" }
					float red_masked_blend_smoothing; // exports={ name="Red Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="1_BLEND_SMOOTHING" }
					#ifndef RED_MATERIAL_MAP
						float red_glossiness; 	// exports={ name="Red Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="1_MATERIAL_MAP_0" }
						float red_specular; 	// exports={ name="Red Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="1_MATERIAL_MAP_1" }
					#endif
				#endif
				#ifdef GREEN_BLEND
					float2 green_maps_scale; // exports={ name="Green Blend - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] sort_tag="2_BLEND_SMOOTHING"}
					float green_masked_blend_smoothing; // exports={ name="Green Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="2_BLEND_SMOOTHING" }
					#ifndef GREEN_MATERIAL_MAP
						float green_glossiness; 	// exports={ name="Green Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="2_MATERIAL_MAP_0" }
						float green_specular; 	// exports={ name="Green Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="2_MATERIAL_MAP_1" }
					#endif
				#endif
				#ifdef BLUE_BLEND
					float2 blue_maps_scale; // exports={ name="Blue Blend - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] sort_tag="3_BLEND_SMOOTHING" }
					float blue_masked_blend_smoothing; // exports={ name="Blue Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="3_BLEND_SMOOTHING" }
					#ifndef BLUE_MATERIAL_MAP
						float blue_glossiness; 	// exports={ name="Blue Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="3_MATERIAL_MAP_0" }
						float blue_specular; 	// exports={ name="Blue Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="3_MATERIAL_MAP_1" }
					#endif
				#endif				
				#ifdef ALPHA_BLEND
					float2 alpha_maps_scale; // exports={ name="Alpha Blend - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] sort_tag="4_BLEND_SMOOTHING" }
					float alpha_masked_blend_smoothing; // exports={ name="Alpha Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="4_BLEND_SMOOTHING" }
					#ifndef ALPHA_MATERIAL_MAP
						float alpha_glossiness; // exports={ name="Alpha Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="4_MATERIAL_MAP_0" }
						float alpha_specular; 	// exports={ name="Alpha Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="4_MATERIAL_MAP_1" }
					#endif
				#endif				
				
				#ifdef DETAIL_FADE
					float2 fade_out_detail_settings; // exports={ name="Fade out details [start, fade]" type="vector2" value=[30 20] min=[5 1] max=[500 250] step=[0.5 0.5] sort_tag="DETAIL_FADE" }
				#endif
				
				#ifdef X360
					float vertices_per_patch;
				#endif
				
				#if defined(GL2)
					float2 inv_hmap_size;
				#endif
				
				float4 dev_wireframe_color;
			CBUFFER_END
								
			#if defined(D3D11)
				sampler clamp_linear;
				Texture2D<float> hmap;	
				Buffer<float4> idata;
			#elif defined(GL2)
				sampler2D hmap;
			#endif
			sampler2D blend_mask;
			 
			#if defined(X360)
				sampler2D hmap;			
				sampler vdata : register(vf0);
				sampler idata : register(vf1); 

				PS_INPUT vs_main(int index : INDEX) {					
					VS_INPUT input;
					
					int outer_index = (index + 0.5) / (int)vertices_per_patch;
					
					float4 pos_scale, tile_info;		
					asm { 
						vfetch_full pos_scale, outer_index, idata, DataFormat=FMT_32_32_32_32_FLOAT, Stride=8, PrefetchCount=8
						vfetch_mini tile_info, DataFormat=FMT_32_32_32_32_FLOAT, Offset=4
					}; 
					
					
					float4 position;
					int inner_index = index - outer_index * (int)vertices_per_patch;	
					asm { 
						vfetch_full position, inner_index, vdata, DataFormat=FMT_32_32_FLOAT, Stride=2, PrefetchCount=2						
					};
					
					input.position = position;					
			#else
				PS_INPUT vs_main(VS_INPUT input, uint instance_id : SV_InstanceId) {
			#endif
				PS_INPUT o;
				
				#if defined(GL2)
					float4 pos_scale = input.pos_scale;
					float4 tile_info = input.tile_info;
					//float4 pos_scale = float4(0,0,32, 32);
					//float4 tile_info = float4(0, 32, 32, 0);
				#elif defined(D3D11)
					float4 pos_scale = idata.Load(instance_id * 2 + 0);
					float4 tile_info = idata.Load(instance_id * 2 + 1);
				#endif
								
				float2 half_size = landscape_size.xy * 0.5;
				float2 mip = input.position.xy;				
				float2 pos = (mip.xy - 0.5) * pos_scale.zw + pos_scale.xy;
								
				float3 wp = mul(float4(pos, 0, 1), world);
				float t = 1-saturate((distance(wp, camera_pos) - (tile_info.x - pos_scale.z*0.5)) / tile_info.y);				
				pos = morph(input.position.xy, pos, t, 32, pos_scale.z);

				float2 huv = ((pos.xy / half_size) * 0.5 + 0.5);
				#if defined(D3D11) || defined(X360)
					huv.y = 1-huv.y;
				#endif
				
				#if defined(D3D11)
					float h = hmap.SampleLevel(clamp_linear, huv, 0).r * landscape_size.z;
				#else
					float h = tex2Dlod(hmap, float4(huv,0,0)).r * landscape_size.z;
				#endif
				
				float4 p = mul(float4(pos.xy, h, 1), world_view_proj);
				o.position = p;
				o.uv = huv;
				
				const float3 lod_cols[8] = {
					float3(1,0,0),
					float3(0,1,0),
					float3(0,0,1),
					float3(1,1,0),
					float3(0,1,1),
					float3(1,1,0.5),
					float3(1,0,0.5),
					float3(0,1,0.5)
				};
				
				o.color = float4(lod_cols[(uint)tile_info.w],t);
				
				o.depth = float2(p.z + camera_near_far.x, 0);
				#if defined(USE_DEPTH_RT)
					#if defined(GL2)
						o.depth.y = linearize_depth(p.z*0.5 / p.w + 0.5);
					#else
						o.depth.y = linearize_depth(p.z / p.w);
					#endif
				#endif

				return o;
			}			
			
			void landscape_layer(inout half4 tnormal, inout half3 diffuse_color, inout half3 gsm, half opacity, half smoothing, bool threshold_blending, half4 layer_normal, half3 layer_diffuse_color, half3 layer_gsm, half fadeout) {				
				//opacity = threshold_blending ? smoothstep(saturate(gsm.b - smoothing), gsm.b, opacity) : opacity;				
				opacity = threshold_blending ? 1-saturate((gsm.b - opacity) / smoothing) : opacity;	
				#if defined(DETAIL_FADE)
					opacity *= fadeout;
				#endif				
				diffuse_color = lerp(diffuse_color, layer_diffuse_color, opacity);				
				tnormal = lerp(tnormal, layer_normal, opacity);
				gsm = lerp(gsm, layer_gsm, opacity);
			}
			
			#ifdef DRAW_WIREFRAME
				float4 ps_main(PS_INPUT input) : SV_TARGET0 {
					return dev_wireframe_color;					
				}			
			#else						
				GBUFFER_OUT ps_main(PS_INPUT input) {				
					GBUFFER_OUT o;				
				
					#if defined(GL2)
						float3 n = normal_from_hmap(hmap, input.uv, inv_hmap_size, 1000);
					#elif defined(D3D11)
						float2 res;
						hmap.GetDimensions(res.x, res.y);
						float3 n = normal_from_hmap(hmap, clamp_linear, input.uv, 1.0/res, 1000);				
					#else
						float3 n = normal_from_hmap(hmap, input.uv, 1000);
					#endif
					
					#ifndef X360
						#ifdef DIFFUSE_MAP
							float3 diffuse_color = tex2D(diffuse_map, input.uv * base_map_scale);
						#else
							float3 diffuse_color = float3(0.5,0.5,0.5);
						#endif
						
						#ifdef MATERIAL_MAP
							half3 gsm = tex2D(material_map, input.uv * base_map_scale).rgb;
						#else
							half3 gsm = half3(glossiness, specular, 0.f);
						#endif				

						#if defined(DETAIL_FADE)
							float4 mask = float4(0,0,0,0);
							half fadeout = 1-saturate((input.depth - fade_out_detail_settings.x) / fade_out_detail_settings.y);						
							if (fadeout > 0)
								mask = tex2D(blend_mask, input.uv);											
						#else
							float4 mask = tex2D(blend_mask, input.uv);
							half fadeout = 1;
						#endif				
						
						#ifdef NORMAL_MAP
							float4 tnormal = tex2D(normal_map, input.uv * base_map_scale);
							tnormal = normalize(tnormal);
						#else
							float4 tnormal = float4(0.5, 0.5, 0.5, 0);
						#endif
						
						half3 layer_gsm;
						half4 layer_diffuse_color;
						half4 layer_normal;
						half opacity;								
						#if defined(RED_BLEND)					
							opacity = mask.r;
							red_maps_scale *= opacity > 0 ? 1 : 0;					
							if (opacity > 0.0) {
								#if defined(RED_DIFFUSE_MAP)						
									layer_diffuse_color = tex2D(first_blend_diffuse_map, input.uv * red_maps_scale);							
								#else
									layer_diffuse_color.rgb = diffuse_color;
									layer_diffuse_color.a = 0;
								#endif
								
								#if defined(RED_MATERIAL_MAP)						
									layer_gsm = tex2D(first_blend_material_map, input.uv * red_maps_scale).rgb;
									#if !defined(RED_WRITE_HEIGHT)
										layer_gsm.b = gsm.b;
									#endif						
								#else						
									layer_gsm = float3(red_glossiness, red_specular, gsm.b);
									#if defined(RED_WRITE_HEIGHT)
										gsm.b = layer_diffuse_color.a;
									#endif
								#endif
								
								#if defined(RED_NORMAL_MAP)
									layer_normal = tex2D(first_blend_normal_map, input.uv * red_maps_scale);
								#else
									layer_normal = float4(0.5, 0.5, 0.5, 0);
								#endif
								
								#if defined(RED_THRESHOLD_BLENDING)
									static const bool red_threshold_blending = true;
								#else
									static const bool red_threshold_blending = false;
								#endif
								landscape_layer(tnormal, diffuse_color, gsm, opacity, red_masked_blend_smoothing, red_threshold_blending, layer_normal, layer_diffuse_color.rgb, layer_gsm, fadeout);
							}
						#endif				
						
						#if defined(GREEN_BLEND)					
							opacity = mask.g;
							green_maps_scale *= opacity > 0 ? 1 : 0;					
							if (opacity > 0.0) {
								#if defined(GREEN_DIFFUSE_MAP)
									layer_diffuse_color = tex2D(second_blend_diffuse_map, input.uv * green_maps_scale);
								#else
									layer_diffuse_color.rgb = diffuse_color;
									layer_diffuse_color.a = 0;
								#endif
								
								#if defined(GREEN_MATERIAL_MAP)
									layer_gsm = tex2D(second_blend_material_map, input.uv * green_maps_scale).rgb;
									#if !defined(GREEN_WRITE_HEIGHT)
										layer_gsm.b = gsm.b;
									#endif
								#else
									layer_gsm = float3(green_glossiness, green_specular, gsm.b);
									#if defined(RED_WRITE_HEIGHT)
										layer_gsm.b = layer_diffuse_color.a;
									#endif						
								#endif										
								
								#if defined(GREEN_NORMAL_MAP)
									layer_normal = tex2D(second_blend_normal_map, input.uv * green_maps_scale);
								#else
									layer_normal = float4(0.5, 0.5, 0.5, 0);
								#endif

								#if defined(GREEN_THRESHOLD_BLENDING)
									static const bool green_threshold_blending = true;
								#else
									static const bool green_threshold_blending = false;
								#endif					
								landscape_layer(tnormal, diffuse_color, gsm, opacity, green_masked_blend_smoothing, green_threshold_blending, layer_normal, layer_diffuse_color.rgb, layer_gsm, fadeout);					
							}
						#endif				

						#if defined(BLUE_BLEND)					
							opacity = mask.b;
							blue_maps_scale *= opacity > 0 ? 1 : 0;					
							if (opacity > 0.0) {
								#if defined(BLUE_DIFFUSE_MAP)
									layer_diffuse_color = tex2D(third_blend_diffuse_map, input.uv * blue_maps_scale);
								#else
									layer_diffuse_color.rgb = diffuse_color;
									layer_diffuse_color.a = 0;
								#endif
								
								#if defined(BLUE_MATERIAL_MAP)
									layer_gsm = tex2D(third_blend_material_map, input.uv * blue_maps_scale).rgb;
									#if !defined(BLUE_WRITE_HEIGHT)
										layer_gsm.b = gsm.b;
									#endif						
								#else
									layer_gsm = float3(blue_glossiness, blue_specular, gsm.b);
									#if defined(RED_WRITE_HEIGHT)
										layer_gsm.b = layer_diffuse_color.a;
									#endif
								#endif										
								
								#if defined(BLUE_NORMAL_MAP)
									layer_normal = tex2D(third_blend_normal_map, input.uv * blue_maps_scale);
								#else
									layer_normal = float4(0.5, 0.5, 0.5, 0);
								#endif
								
								#if defined(BLUE_THRESHOLD_BLENDING)
									static const bool blue_threshold_blending = true;
								#else
									static const bool blue_threshold_blending = false;
								#endif					
								landscape_layer(tnormal, diffuse_color, gsm, opacity, blue_masked_blend_smoothing, blue_threshold_blending, layer_normal, layer_diffuse_color.rgb, layer_gsm, fadeout);
							}
						#endif				

						#if defined(ALPHA_BLEND)
							opacity = mask.a;
							alpha_maps_scale *= opacity > 0 ? 1 : 0;					
							if (opacity > 0.0) {
								#if defined(ALPHA_DIFFUSE_MAP)
									layer_diffuse_color = tex2D(fourth_blend_diffuse_map, input.uv * alpha_maps_scale);
								#else
									layer_diffuse_color.rgb = diffuse_color;
									layer_diffuse_color.a = 0;
								#endif
								
								#if defined(ALPHA_MATERIAL_MAP)
									layer_gsm = tex2D(fourth_blend_material_map, input.uv * alpha_maps_scale).rgb;
									#if !defined(ALPHA_WRITE_HEIGHT)
										layer_gsm.b = gsm.b;
									#endif						
								#else
									layer_gsm = float3(alpha_glossiness, alpha_specular, gsm.b);
									#if defined(RED_WRITE_HEIGHT)
										layer_gsm.b = layer_diffuse_color.a;
									#endif						
								#endif					
								
								#if defined(ALPHA_NORMAL_MAP)
									layer_normal = tex2D(fourth_blend_normal_map, input.uv * alpha_maps_scale);
								#else
									layer_normal = float4(0.5, 0.5, 0.5, 0);
								#endif
								
								#if defined(ALPHA_THRESHOLD_BLENDING)
									static const bool alpha_threshold_blending = true;
								#else
									static const bool alpha_threshold_blending = false;
								#endif					
								landscape_layer(tnormal, diffuse_color, gsm, opacity, alpha_masked_blend_smoothing, alpha_threshold_blending, layer_normal, layer_diffuse_color.rgb, layer_gsm, fadeout);
							}
						#endif				
						
						tnormal.xyz = normalize(decode_normal_map(tnormal));
						n = half3(n.xy + tnormal.xy, n.z * tnormal.z);
						
					#else
						float4 mask = tex2D(blend_mask, input.uv);	
						float3 diffuse_color = mask.rgb;
						half3 gsm = half3(0.5, 0.5, 0.5);
					#endif
					

					ALBEDO(o) = gbuffer_encode_albedo(diffuse_color);
					NORMAL(o) = gbuffer_encode_normal(normalize(n));
					SPECULAR(o) = gbuffer_encode_specular_mask(gsm.g);
					GLOSSINESS(o) = gbuffer_encode_glossiness(gsm.r);	
					GBUFFER_AUX(o) = half4(0, DEFAULT_MATERIAL, 0, 1);

					#if defined(USE_DEPTH_RT)
						DEPTH(o) = gbuffer_encode_depth(input.depth.y);
					#endif
					
					return o;				
				}			
			#endif
		"""
	}
		
	simple_landscape = {
		includes = [ "common", "gbuffer_access", "landscape_shared" ]
		
		samplers = {		
			defined_D3D11 = {
				clamp_linear = { sampler_states = "clamp_linear" }
			}
			ndefined_D3D11 = {
				hmap = { sampler_states = "clamp_linear" }
			}
			blend_mask = { sampler_states = "clamp_linear" }
			
			normal_map = { sampler_states = "landscape_anisotropic" }
			blend_diffuse_map = { sampler_states = "landscape_anisotropic" }
			material_map = { sampler_states = "clamp_linear_srgb" }
		}
		
		code="""
			struct VS_INPUT {
				float2 position : POSITION;
				#if defined(GL2)
					float4 pos_scale : TEXCOORD0;
					float4 tile_info : TEXCOORD1;
				#endif
				#if defined(GCM)
					float height : TEXCOORD0;
				#endif				
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
				float2 uv : TEXCOORD0;
				float2 depth : TEXCOORD1;
				float4 color : COLOR;
			};
			
			sampler2D normal_map; // exports={ name="Multi-Material Height Map" type="resource" sort_tag="0_NORMAL_MAP" }
			sampler2D blend_diffuse_map; // exports = { name="Multi-Material Diffuse Blend Map" type="resource" sort="1_DIFFUSE_MAP" }
			sampler2D material_map; // exports = { name="Multi-Material Diffuse Gradient Map" type="resource" sort="2_DIFFUSE_MAP" }			
			
			#if defined(RED_DIFFUSE_MAP) || defined(RED_NORMAL_MAP) || defined(RED_MATERIAL_MAP)
				#define RED_BLEND
			#endif
			#if defined(GREEN_DIFFUSE_MAP) || defined(GREEN_NORMAL_MAP) || defined(GREEN_MATERIAL_MAP)
				#define GREEN_BLEND
			#endif
			#if defined(BLUE_DIFFUSE_MAP) || defined(BLUE_NORMAL_MAP) || defined(BLUE_MATERIAL_MAP)
				#define BLUE_BLEND
			#endif
			#if defined(ALPHA_DIFFUSE_MAP) || defined(ALPHA_NORMAL_MAP) || defined(ALPHA_MATERIAL_MAP)
				#define ALPHA_BLEND
			#endif
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float4x4 world;
				float3 landscape_size;
				float3 lod_camera_pos;
				#ifndef MATERIAL_MAP
					float glossiness; 	// exports={ name="Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="0_MATERIAL_MAP_0" }
					float specular; 	// exports={ name="Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="0_MATERIAL_MAP_1" }
				#endif
				
				float2 material_height_maps_scale; // exports={ name="Material Height Map - UV Scale" type="vector2" value=[1 1] min=[0 0] max=[1024 1024] step=[1 1] sort_tag="1_BLEND_SMOOTHING" }
				
				#ifdef RED_BLEND
					float red_normal_strength; // exports={ name="Red Blend - Normal Strength" type="scalar" value=10 min=0 max=100 step=0.1 sort_tag="1_BLEND_SMOOTHING" }
					float red_masked_blend_smoothing; // exports={ name="Red Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="1_BLEND_SMOOTHING" }
					float red_glossiness; 	// exports={ name="Red Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="1_MATERIAL_MAP_0" }
					float red_specular; 	// exports={ name="Red Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="1_MATERIAL_MAP_1" }
				#endif
				#ifdef GREEN_BLEND
					float green_normal_strength; // exports={ name="Green Blend - Normal Strength" type="scalar" value=10 min=0 max=100 step=0.1 sort_tag="1_BLEND_SMOOTHING" }
					float green_masked_blend_smoothing; // exports={ name="Green Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="2_BLEND_SMOOTHING" }
					float green_glossiness; 	// exports={ name="Green Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="2_MATERIAL_MAP_0" }
					float green_specular; 	// exports={ name="Green Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="2_MATERIAL_MAP_1" }
				#endif
				#ifdef BLUE_BLEND
					float blue_normal_strength; // exports={ name="Blue Blend - Normal Strength" type="scalar" value=10 min=0 max=100 step=0.1 sort_tag="1_BLEND_SMOOTHING" }
					float blue_masked_blend_smoothing; // exports={ name="Blue Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="3_BLEND_SMOOTHING" }
					float blue_glossiness; 	// exports={ name="Blue Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="3_MATERIAL_MAP_0" }
					float blue_specular; 	// exports={ name="Blue Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="3_MATERIAL_MAP_1" }
				#endif				
				#ifdef ALPHA_BLEND
					float alpha_normal_strength; // exports={ name="Alpha Blend - Normal Strength" type="scalar" value=10 min=0 max=100 step=0.1 sort_tag="1_BLEND_SMOOTHING" }
					float alpha_masked_blend_smoothing; // exports={ name="Alpha Blend - Smoothing" type="scalar" value=0.2 min=0.001 max=1.0 step=0.001 sort_tag="4_BLEND_SMOOTHING" }
					float alpha_glossiness; // exports={ name="Alpha Blend - Glossiness Amount" type="scalar" value=0.5 min=0.0 max=1.0 step=0.001 sort_tag="4_MATERIAL_MAP_0" }
					float alpha_specular; 	// exports={ name="Alpha Blend - Specular Mask" type="scalar" value=0.8 min=0.0 max=1.0 step=0.001 sort_tag="4_MATERIAL_MAP_1" }
				#endif				
				
				#ifdef X360
					float vertices_per_patch;
				#endif
				
				#if defined(GL2) || defined(GCM)
					float2 inv_hmap_size;
				#endif
				#ifdef GCM
					float4 patch_offset_scale;
				#endif		
				float4 dev_wireframe_color;
			CBUFFER_END
								
			#if defined(D3D11)
				sampler clamp_linear;
				Texture2D<float> hmap;	
				Buffer<float4> idata;
			#elif defined(GL2) || defined(GCM)
				sampler2D hmap;
			#endif
			sampler2D blend_mask;
			 
			#if defined(X360)
				sampler2D hmap;			
				sampler vdata : register(vf0);
				sampler idata : register(vf1); 

				PS_INPUT vs_main(int index : INDEX) {					
					VS_INPUT input;
					
					int outer_index = (index + 0.5) / (int)vertices_per_patch;
					
					float4 pos_scale, tile_info;		
					asm { 
						vfetch_full pos_scale, outer_index, idata, DataFormat=FMT_32_32_32_32_FLOAT, Stride=8, PrefetchCount=8
						vfetch_mini tile_info, DataFormat=FMT_32_32_32_32_FLOAT, Offset=4
					}; 
					
					
					float4 position;
					int inner_index = index - outer_index * (int)vertices_per_patch;	
					asm { 
						vfetch_full position, inner_index, vdata, DataFormat=FMT_32_32_FLOAT, Stride=2, PrefetchCount=2						
					};
					
					input.position = position;					
			#elif defined(GCM)
				PS_INPUT vs_main(VS_INPUT input) {
			#else
				PS_INPUT vs_main(VS_INPUT input, uint instance_id : SV_InstanceId) {
			#endif
				PS_INPUT o;
				
				#if defined(GL2)
					float4 pos_scale = input.pos_scale;
					float4 tile_info = input.tile_info;
				#elif defined(D3D11)
					float4 pos_scale = idata.Load(instance_id * 2 + 0);
					float4 tile_info = idata.Load(instance_id * 2 + 1);
				#elif defined(GCM)
					float4 pos_scale = patch_offset_scale;
					float4 tile_info = float4(0,0,0,0);				
				#endif
								
				float2 half_size = landscape_size.xy * 0.5;
				float2 mip = input.position.xy;				
				float2 pos = (mip.xy - 0.5) * pos_scale.zw + pos_scale.xy;
								
				float3 wp = mul(float4(pos, 0, 1), world);
				float t = 1-saturate((distance(wp, camera_pos) - (tile_info.x - pos_scale.z*0.5)) / tile_info.y);								
				#ifndef GCM
					pos = morph(input.position.xy, pos, t, 32, pos_scale.z);
				#endif

				float2 huv = ((pos.xy / half_size) * 0.5 + 0.5);
				#if defined(D3D11) || defined(X360) || defined(GCM)
					huv.y = 1-huv.y;
				#endif
				
				#if defined(D3D11)
					float h = hmap.SampleLevel(clamp_linear, huv, 0).r * landscape_size.z;
				#else
					float h = tex2Dlod(hmap, float4(huv,0,0)).r * landscape_size.z;
				#endif
				
				float4 p = mul(float4(pos.xy, h, 1), world_view_proj);
				o.position = p;
				o.uv = huv;
				
				const float3 lod_cols[8] = {
					float3(1,0,0),
					float3(0,1,0),
					float3(0,0,1),
					float3(1,1,0),
					float3(0,1,1),
					float3(1,1,0.5),
					float3(1,0,0.5),
					float3(0,1,0.5)
				};
				
				#if defined(GCM)
					o.color = float4(1,1,1,1);
				#else
					o.color = float4(lod_cols[(uint)tile_info.w],t);
				#endif
								
				o.depth = float2(p.z + camera_near_far.x, 0);
				#if defined(USE_DEPTH_RT)
					#if defined(GL2)
						o.depth.y = linearize_depth(p.z*0.5 / p.w + 0.5);
					#else
						o.depth.y = linearize_depth(p.z / p.w);
					#endif
				#endif
				
				return o;
			}			
			
			void landscape_layer(inout half3 tnormal, inout half3 diffuse_color, inout half3 gsm, half opacity, half smoothing, bool threshold_blending, half3 layer_normal, half3 layer_diffuse_color, half3 layer_gsm, half fadeout) {				
				opacity = threshold_blending ? 1-saturate((gsm.b - opacity) / smoothing) : opacity;	
				#if defined(DETAIL_FADE)
					opacity *= fadeout;
				#endif
				diffuse_color = lerp(diffuse_color, layer_diffuse_color, opacity);				
				tnormal = lerp(tnormal, layer_normal, opacity);
				gsm = lerp(gsm, layer_gsm, opacity);
			}
			
			#ifdef DRAW_WIREFRAME
				float4 ps_main(PS_INPUT input) : SV_TARGET0 {
					return dev_wireframe_color;					
				}			
			#else									
				GBUFFER_OUT ps_main(PS_INPUT input) {				
					GBUFFER_OUT o;				
				
					#if defined(GL2) || defined(GCM)
						float3 n = normal_from_hmap(hmap, input.uv, inv_hmap_size, 1000);
					#elif defined(D3D11)
						float2 res;
						hmap.GetDimensions(res.x, res.y);
						float3 n = normal_from_hmap(hmap, clamp_linear, input.uv, 1.0/res, 1000);				
					#else
						float3 n = normal_from_hmap(hmap, input.uv, 1000);
					#endif				
					
					float4 mask = tex2D(blend_mask, input.uv);	
					half3 diffuse_color = float3(0.5, 0.5, 0.5);
					half3 gsm = half3(0,0,0);
					half3 tnormal = float3(0,0,1);				
					
					float4 material_strengths = float4(red_normal_strength,green_normal_strength,blue_normal_strength,alpha_normal_strength);
					float2 uv = input.uv * material_height_maps_scale;
					float2 offs = float2(1.f / 1024.f, 1.f / 1024.f);
					
					float4 h = tex2D(normal_map, uv);
					float4 h0 = h * material_strengths;
					float4 h1 = tex2D(normal_map, uv + float2(offs.x, 0)) * material_strengths;
					float4 h2 = tex2D(normal_map, uv + float2(0, offs.y)) * material_strengths;
					
					float4 dx = h0 - h1;
					float4 dy = h2 - h0;
					
					float3 layer_normal;
					float3 layer_diffuse_color = float3(0.5, 0.5, 0.5);					
					float3 layer_gsm;
					
					#define GRADIENT_TEXTURE_SIZE 16
					#define GRADIENT_MATERIAL_OFFSET 4.0 / GRADIENT_TEXTURE_SIZE
					#define GRADIENT_MATERIAL_OFFSET_BIAS 2.0 / GRADIENT_TEXTURE_SIZE
					
					float4 diffuse_control = tex2D(blend_diffuse_map, uv) * ((GRADIENT_TEXTURE_SIZE - 1.0)/GRADIENT_TEXTURE_SIZE) + 0.5 / GRADIENT_TEXTURE_SIZE;
					
					#if defined(RED_BLEND)
						layer_diffuse_color = tex2Dlod(material_map, float4(diffuse_control.x, 0*GRADIENT_MATERIAL_OFFSET+GRADIENT_MATERIAL_OFFSET_BIAS, 0, 0)); //tex2D(first_blend_diffuse_map, uv).rgb;
						layer_gsm = float3(red_glossiness, red_specular, h.x);
						layer_normal = float3(dx.x, dy.x, 2.f);
						landscape_layer(tnormal, diffuse_color, gsm, mask.x, red_masked_blend_smoothing, false, layer_normal, layer_diffuse_color.rgb, layer_gsm, 0.f);
					#endif					

					#if defined(GREEN_BLEND)
						layer_diffuse_color = tex2Dlod(material_map, float4(diffuse_control.y, 1*GRADIENT_MATERIAL_OFFSET+GRADIENT_MATERIAL_OFFSET_BIAS,0,0)); //tex2D(first_blend_diffuse_map, uv).rgb;
						layer_gsm = float3(green_glossiness, green_specular, h.y);
						layer_normal = float3(dx.y, dy.y, 2.f);
						landscape_layer(tnormal, diffuse_color, gsm, mask.y, green_masked_blend_smoothing, true, layer_normal, layer_diffuse_color.rgb, layer_gsm, 0.f);
					#endif					

					#if defined(BLUE_BLEND)
						layer_diffuse_color = tex2Dlod(material_map, float4(diffuse_control.z, 2*GRADIENT_MATERIAL_OFFSET+GRADIENT_MATERIAL_OFFSET_BIAS,0,0)); //tex2D(first_blend_diffuse_map, uv).rgb;
						layer_gsm = float3(blue_glossiness, blue_specular, h.z);
						layer_normal = float3(dx.z, dy.z, 2.f);
						landscape_layer(tnormal, diffuse_color, gsm, mask.z, blue_masked_blend_smoothing, true, layer_normal, layer_diffuse_color.rgb, layer_gsm, 0.f);
					#endif
					
					#if defined(ALPHA_BLEND)
						layer_diffuse_color = tex2Dlod(material_map, float4(diffuse_control.w, 3*GRADIENT_MATERIAL_OFFSET+GRADIENT_MATERIAL_OFFSET_BIAS,0,0)); //tex2D(first_blend_diffuse_map, uv).rgb;
						layer_gsm = float3(alpha_glossiness, alpha_specular, h.w);
						layer_normal = float3(dx.w, dy.w, 2.f);
						landscape_layer(tnormal, diffuse_color, gsm, mask.w, alpha_masked_blend_smoothing, true, layer_normal, layer_diffuse_color.rgb, layer_gsm, 0.f);
					#endif
					
					tnormal = normalize(tnormal);
					n = half3(n.xy + tnormal.xy, n.z * tnormal.z);

					ALBEDO(o) = gbuffer_encode_albedo(diffuse_color);
					NORMAL(o) = gbuffer_encode_normal(normalize(n));
					SPECULAR(o) = gbuffer_encode_specular_mask(gsm.g);
					GLOSSINESS(o) = gbuffer_encode_glossiness(gsm.r);
					GBUFFER_AUX(o) = half4(0, DEFAULT_MATERIAL, 0, 1);
					
					#if defined(USE_DEPTH_RT)
						DEPTH(o) = gbuffer_encode_depth(input.depth.y);
					#endif
					
					return o;				
				}			
			#endif
		"""
	}	
	landscape_layer = {
		code="""
			float4 landscape_layer(sampler2D map, float2 uv, float2 uv_scale, float2 uv_offset) {
				float2 final_uv = uv * uv_scale + uv_offset;
				return tex2D(map, final_uv);
			}
		"""
	}
		
	landscape_editor_brush = {		
		includes = [ "common", "gbuffer_access" ]
		 
		samplers = {
			defined_SAMPLE_BASED = {
				input_texture0 = { sampler_states = "clamp_linear" }
			}			
		}

		code="""
			struct VS_INPUT {
				float4 position : POSITION;
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
				#if defined(SAMPLE_HEIGHT)
					float world_height : TEXCOORD0;
					float layer_value : TEXCOORD1;
				#else
					float2 uv : TEXCOORD0;				
				#endif				
			};			 			
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float radius;
				float strength;
				float falloff;
				float mask_idx;
				float3 mouse_pos;
				float4x4 inverse_landscape_wtm;
				float2 landscape_size;				
				float3 camera_ray_origin;
				float3 camera_ray_direction;
				#ifdef SAMPLE_BASED
					float2 inv_input_texture0_size;
				#endif
			CBUFFER_END
			
			Texture2D<float> depth;
			#if defined(SAMPLE_HEIGHT)
				Texture2D<float4> output;
			#elif defined(SAMPLE_BASED)
				sampler2D input_texture0;
			#endif	
			
			#ifndef SAMPLE_HEIGHT
				Texture2D<float4> height_sample;
			#endif

			PS_INPUT vs_main(VS_INPUT input) {
				PS_INPUT o;

				#if defined(SAMPLE_HEIGHT)
					// Reconstruct world height from pixel behind back buffer
					float3 smp = float3(mouse_pos.x/back_buffer_size.x, mouse_pos.z/back_buffer_size.y, 0) * 2 - 1;				
					float4 w = encode_world_pos(float4(smp,1), camera_unprojection);
					float d = gbuffer_decode_depth(depth.Load(int3(mouse_pos.x, back_buffer_size.y-mouse_pos.z, 0)));
					//float d = gbuffer_decode_depth(depth.Load(int3(mouse_pos.x, mouse_pos.z, 0)));
					float3 wp = decode_world_pos(w, d);
					
					o.world_height = wp.z;				
					
					// Sample active layer value
					float3 landscape_pos = mul(float4(wp, 1), inverse_landscape_wtm);
					float2 half_size = landscape_size * 0.5;
					float2 huv = ((landscape_pos.xy / half_size) * 0.5 + 0.5);
					huv.y = 1-huv.y;
					 
					float2 layer_res;
					output.GetDimensions(layer_res.x, layer_res.y);				
					
					o.layer_value = output.Load(int3(layer_res * huv.xy,0))[(int)mask_idx];
				#else
					// Find camera ray/landscape intersection, landscape is represented as a plane with normal [0,0,1] and d=last sampled world height
					float world_height = height_sample.Load(int3(0,0,0)).r;
					float t = (world_height - camera_ray_origin.z)/camera_ray_direction.z;					
					float3 wp = camera_ray_origin + camera_ray_direction * t;
					
					o.uv = input.position.xy;
					
					float3 landscape_pos = mul(float4(wp, 1), inverse_landscape_wtm);
					landscape_pos.xy = clamp(2*(landscape_pos.xy / landscape_size), -1, 1);
					//landscape_pos.y = -landscape_pos.y;
					
					float2 scale = (2*radius.xx) / landscape_size;
					#if defined(SAMPLE)
						// Increase brush size with filter kernel size
						scale += inv_input_texture0_size*2;
					#endif
					input.position.xy *= scale;
					input.position.xy += landscape_pos.xy;					
				#endif
				
				o.position =  mul(input.position, world_view_proj);
				return o;
			}			
			
			float4 ps_main(PS_INPUT input) :  SV_TARGET0 {		
				static float4 mask_lookup[4] = {
					float4(1,0,0,0),
					float4(0,1,0,0),
					float4(0,0,1,0),
					float4(0,0,0,1)					
				};
				
				#ifdef SAMPLE_HEIGHT
					return float4(input.world_height, input.layer_value, 0, 0);
				#else
					float phase =  saturate(length(input.uv)) * (3.1415926*0.5);
					float a = cos(phase);
					
					#if defined(FLATTEN)						
						float2 layer_uv = input.position.xy * inv_input_texture0_size;
						float4 center = tex2D(input_texture0, layer_uv);						
						float4 v = center;
						v = (1-mask_lookup[(int)mask_idx]) * v + mask_lookup[(int)mask_idx] * lerp(center[(int)mask_idx], height_sample.Load(int3(0,0,0)).g, a * strength);
						return v;
					#elif defined(SAMPLE)
						float2 layer_uv = input.position.xy * inv_input_texture0_size;
						float4 c = tex2D(input_texture0, layer_uv);
						return c;						
					#else
						a = pow(a, falloff);
					
						#if defined(BOX_FILTER)
							float d = 0.5;
							
							float2 layer_uv = input.position.xy * inv_input_texture0_size;
							float4 center = tex2D(input_texture0, layer_uv);
							float4 c =
								tex2D(input_texture0, layer_uv + half2(-d, -d) * inv_input_texture0_size) +
								tex2D(input_texture0, layer_uv + half2( d, -d) * inv_input_texture0_size) + 
								tex2D(input_texture0, layer_uv + half2(-d,  d) * inv_input_texture0_size) + 
								tex2D(input_texture0, layer_uv + half2( d,  d) * inv_input_texture0_size);
								
							c *= 0.25;
							float4 v = center;
							float4 mask = mask_lookup[(int)mask_idx];							
							v = (1-mask) * v + mask * lerp(center[(int)mask_idx], c[(int)mask_idx], a * strength);
							return v;
						#else							
							float4 v = mask_lookup[(int)mask_idx] * strength * a;
							return v;							
						#endif
					#endif
				#endif				
			}	
		"""
	}	
	
	landscape_editor_brush_marker = {		
		includes = [ "common", "gbuffer_access" ]
		 
		code="""
			struct VS_INPUT {
				float4 position : POSITION;
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
				float4 w : TEXCOORD0;
				float3 center : TEXCOORD1;
			};		
			
			Texture2D<float> depth;
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float4x4 world;
				float radius;
				float falloff;
				float strength;
				float3 brush_color;
				float brush_type;
				float3 mouse_pos;
				float3 camera_ray_origin;  
				float3 camera_ray_direction;				
			CBUFFER_END
			
			Texture2D<float> height_sample;
			
			PS_INPUT vs_main(VS_INPUT input) {
				PS_INPUT o; 
				
				// Find camera ray/landscape intersection, landscape is represented as a plane with normal [0,0,1] and d=last sampled world height
				float world_height = height_sample.Load(int3(0,0,0)).r;
				float t = (world_height - camera_ray_origin.z)/camera_ray_direction.z;					
				float3 wp = camera_ray_origin + camera_ray_direction * t;
				
				input.position.xy *= radius;
				input.position.z *= 1000;				
				input.position.xyz += wp;				
				o.position =  mul(input.position, world_view_proj);				
				o.center = wp; 
				o.w = encode_world_pos(o.position, camera_unprojection);
				return o;
			}			
			
			float4 ps_main(PS_INPUT input) :  SV_TARGET0 {
				float d = gbuffer_decode_depth(depth.Load(int3(input.position.xy,0)));
				float3 wp = decode_world_pos(input.w, d);
				wp.z = 0;
				float l = length(float3(wp.xy,0)-float3(input.center.xy, 0));
				
				float stroke_width = 0.02 * radius;
				float falloff_marker = (1-(0.5 * falloff)) * radius;				
				float4 c;
				
				if (brush_type == 0) {
					float3 mark = l < stroke_width ? float3(1,1,1) : ((l > falloff_marker-stroke_width && l < falloff_marker) || (l > radius-stroke_width && l < radius)) ? brush_color : float3(0,0,0);
					c = float4(mark, dot(mark, float3(1,1,1)) == 0 ? 0 : lerp(0.2, 0.6, strength));
				} else {
					float fade = (l > (falloff_marker-stroke_width) && l < radius) ? (1-saturate((l - falloff_marker) / (radius - falloff_marker))) : 1;				
					float3 mark = l < stroke_width ? float3(1,1,1) : (l < radius) ? brush_color : float3(0,0,0);
					c = float4(mark, dot(mark, float3(1,1,1)) == 0 ? 0 : fade * lerp(0.2, 0.6, strength));
				}		
				return c;
				
			}	
		"""
	}
	
	landscape_undergrowth = {		
		includes = [ "common", "gbuffer_access", "landscape_shared" ]
		samplers = {
			defined_D3D11 = {
				clamp_linear = { sampler_states = "clamp_linear" }
				input_texture1 = { sampler_states = "clamp_linear" }
			}
			ndefined_D3D11 = {
				input_texture0 = { sampler_states = "clamp_linear" }
				input_texture1 = { sampler_states = "clamp_linear" }
			}
		}
		 
		code="""
			#if defined(D3D11)
				sampler clamp_linear;
				Texture2D<float> input_texture0;
				sampler2D input_texture1;
			#elif defined(GL2)
				sampler2D input_texture0;
				sampler2D input_texture1;
			#endif
						
			struct VS_INPUT {
				float4 position : POSITION;
				float2 uv : TEXCOORD0;				
			};
			
			struct PS_INPUT {
				float4 position : SV_POSITION;
				float2 uv : TEXCOORD0;
			};			 			
			
			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float2 scale;
				float2 offset;
				float height;
				#if defined(GL2)
					float2 inv_input_texture0_size;
				#endif
			CBUFFER_END
			
			struct UNDERGROWTH_OUT { 
				half4 buffer0 : COLOR0;
				half4 buffer1 : COLOR1;
			};
			
			PS_INPUT vs_main(VS_INPUT input) {
				PS_INPUT o;
				o.position = mul(input.position, world_view_proj);				
				float2 uv = input.uv;		
				o.uv = uv * scale + offset;
				#if defined(D3D11)
					o.uv.y = 1-o.uv.y;
				#endif
				
				return o;
			}			
						
			UNDERGROWTH_OUT ps_main(PS_INPUT input) {
				UNDERGROWTH_OUT o;
				#if defined(D3D11)
					float2 res;
					input_texture0.GetDimensions(res.x, res.y);
					float3 hmap_normal = normal_from_hmap(input_texture0, clamp_linear, input.uv, 1.0/res, height);
				#elif defined(GL2)
					float3 hmap_normal = normal_from_hmap(input_texture0, input.uv, inv_input_texture0_size, height);
				#endif
				
				float3 n = encode_signed_normal(hmap_normal);
				
				#if defined(D3D11)
					float h = input_texture0.Sample(clamp_linear, input.uv).r;
				#elif defined(GL2)
					float h = tex2D(input_texture0, input.uv).r;
				#endif
				o.buffer0 = float4(encode_float_rg(h), n.xy /*encode_float_rg(h)*/);
				float4 mat = tex2D(input_texture1, input.uv);
				o.buffer1 = mat;
				return o;
			}	
		"""
	}		
}

shaders = {
	landscape = {
		editor_advanced_mode = false
		
		editor_options = [			
			{				
				name="Base Texture Layers"
				options = [	
					{ name="Diffuse Map" define="DIFFUSE_MAP" }
					{ name="Material Map" define="MATERIAL_MAP" }
					{ name="Normal Map" define="NORMAL_MAP" }
				]
			}
			
			{ 
				name="Deferred Decals" 
				options = [
					{ name="Decal Group 1" define="DEFERRED_DECALS_GROUP_1" }
					{ name="Decal Group 2" define="DEFERRED_DECALS_GROUP_2" }
					{ name="Decal Group 3" define="DEFERRED_DECALS_GROUP_3" }
				]
			}					
						
			
			{				
				name="Settings"
				options = [	
					{ name="Fade-out Mask Textures" define="DETAIL_FADE" }
				]
			}						
			
			{				
				name="Red Mask Blend - Texture Layers"
				options = [						
					{ name="Threshold Blending" define="RED_THRESHOLD_BLENDING" }
					{ name="Writes Height for Threshold Blending" define="RED_WRITE_HEIGHT" }
					{ name="Diffuse Map" define="RED_DIFFUSE_MAP" }
					{ name="Material Map" define="RED_MATERIAL_MAP" }
					{ name="Normal Map" define="RED_NORMAL_MAP" }
				]
			}			
			
			{				
				name="Green Mask Blend - Texture Layers"
				options = [	
					{ name="Threshold Blending" define="GREEN_THRESHOLD_BLENDING" }
					{ name="Writes Height for Threshold Blending" define="GREEN_WRITE_HEIGHT" }
					{ name="Diffuse Map" define="GREEN_DIFFUSE_MAP" }
					{ name="Material Map" define="GREEN_MATERIAL_MAP" }
					{ name="Normal Map" define="GREEN_NORMAL_MAP" }
				]
			}			
			
			{				
				name="Blue Mask Blend - Texture Layers"
				options = [	
					{ name="Threshold Blending" define="BLUE_THRESHOLD_BLENDING" }
					{ name="Writes Height for Threshold Blending" define="BLUE_WRITE_HEIGHT" }
					{ name="Diffuse Map" define="BLUE_DIFFUSE_MAP" }
					{ name="Material Map" define="BLUE_MATERIAL_MAP" }
					{ name="Normal Map" define="BLUE_NORMAL_MAP" }
				]
			}			
			
			{				
				name="Alpha Mask Blend - Texture Layers"
				options = [	
					{ name="Threshold Blending" define="ALPHA_THRESHOLD_BLENDING" }
					{ name="Writes Height for Threshold Blending" define="ALPHA_WRITE_HEIGHT" }
					{ name="Diffuse Map" define="ALPHA_DIFFUSE_MAP" }
					{ name="Material Map" define="ALPHA_MATERIAL_MAP" }
					{ name="Normal Map" define="ALPHA_NORMAL_MAP" }
				]
			}			
		]
		
		contexts = {
			shadow_caster = {
				passes_sort_mode="immediate"
				passes = [
					{ hlsl_shader="landscape_depth" render_states="shadow_caster" }
				]			
			}
			
			default = {
				passes = [
					{ layer="gbuffer" hlsl_shader="landscape" render_states="landscape" }
					{ layer="wireframe" hlsl_shader="landscape" defines="DRAW_WIREFRAME" render_states="wireframe" branch_key="dev_wireframe" }
				]
			}
		}	
		
		compile = {
			shadow_caster = [ 
				{ defines="HWSM" platforms="D3D11 X360" }
				{ defines="" platforms="GL2" }
			] 
			
			default = [
				{ defines="" platforms="D3D11 X360 GL2 GCM" }
			]
		} 
	}
	
	simple_landscape = {
		editor_advanced_mode = false
		
		editor_options = [			
			{				
				name="Material Layers"
				options = [	
					{ name="Red Mask Material" define="RED_BLEND" }
					{ name="Green Mask Material" define="GREEN_BLEND" }
					{ name="Blue Mask Material" define="BLUE_BLEND" }
					{ name="Alpha Mask Material" define="ALPHA_BLEND" }
				]
			}
			
			{ 
				name="Deferred Decals" 
				options = [
					{ name="Decal Group 1" define="DEFERRED_DECALS_GROUP_1" }
					{ name="Decal Group 2" define="DEFERRED_DECALS_GROUP_2" }
					{ name="Decal Group 3" define="DEFERRED_DECALS_GROUP_3" }
				]
			}
		]
		
		contexts = {
			shadow_caster = {
				passes_sort_mode="immediate"
				passes = [
					{ hlsl_shader="landscape_depth" render_states="shadow_caster" }
				]			
			}
			
			default = {
				passes = [
					{ layer="gbuffer" hlsl_shader="simple_landscape" render_states="landscape" }
					{ layer="wireframe" hlsl_shader="simple_landscape" defines="DRAW_WIREFRAME" render_states="wireframe" branch_key="dev_wireframe" }					
				]
			}
		}	
		
		compile = {
			shadow_caster = [ 
				{ defines="HWSM" platforms="D3D11 X360" }
				{ defines="" platforms="GL2" }
			] 
			
			default = [
				{ defines="" }
			]
		} 
	}	
	
	landscape_editor_brush = {
		editor_advanced_mode = true
		
		contexts = {			
			default = {
				passes_sort_mode="immediate"
				passes = [
					{ hlsl_shader="landscape_editor_brush" render_states="brush" }
				]
			}
		}	
		
		compile = {
			default = [
				{ defines="" platforms="D3D11" }
			]
		} 
	}
	
	landscape_editor_brush_marker = {
		editor_advanced_mode = true
		
		contexts = {
			default = {
				passes = [
					{ layer="transparent" hlsl_shader="landscape_editor_brush_marker" render_states="marker" }
				]
			}
		}	
		
		compile = {
			default = [
				{ defines="" platforms="D3D11" }
			]
		} 
	}	
	
	landscape_undergrowth = {
		editor_advanced_mode = true		
		
		contexts = {
			default = {
				passes_sort_mode="immediate"
				passes = [{
					defined="OES2"
					pass = [
					]
					fail = [
						{ hlsl_shader="landscape_undergrowth" render_states="filter" }
					]
				}]
			}
		}	
		
		compile = {			
			default = [
				{ defines="" platforms="D3D11 GL2" }
			]
		} 
	}
}

static_compile = [ 
	{ shader="landscape" platforms="D3D11 GL2 X360 OES2" } 
	{ shader="landscape_editor_brush" defines="" platforms="D3D11" } 
	{ shader="landscape_editor_brush" defines="SUB" platforms="D3D11" } 
	{ shader="landscape_editor_brush" defines="SAMPLE_HEIGHT" platforms="D3D11" } 	
	{ shader="landscape_editor_brush" defines="SAMPLE_BASED FLATTEN" platforms="D3D11" } 	
	{ shader="landscape_editor_brush" defines="SAMPLE_BASED SAMPLE" platforms="D3D11" } 	
	{ shader="landscape_editor_brush" defines="SAMPLE_BASED BOX_FILTER" platforms="D3D11" } 	
	{ shader="landscape_editor_brush_marker" defines="" platforms="D3D11" } 	
	{ shader="landscape_undergrowth" defines="" platforms="D3D11 GL2 OES2" }
]